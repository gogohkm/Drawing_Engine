아래 파일로 **“AI가 그대로 읽고 도면을 그릴 수 있는 절차형 제도 노트(버전 1.0)”**를 작성해 두었습니다.
(모델/레이아웃, 레이어 네이밍, 주석 스케일, Xref, 스케줄 자동화, 철근/철골 상세까지 AI 실행 순서 중심으로 정리)

제도 안내 노트 DOCX 다운로드

제도 안내 노트 PDF 다운로드

이 노트가 기반으로 삼는 “핵심 표준/강좌 관행” (요약)

노트 내용은 아래와 같은 업계 표준/공식 문서/강좌 관행을 종합한 절차형 가이드입니다.

모델(1:1) + 레이아웃(뷰포트 축척) 분리가 기본 작업 방식

**Annotative(주석 스케일)**을 쓰면 여러 축척에서 텍스트/치수 가독성을 유지 가능

NCS/AIA 레이어 네이밍(Discipline+Major 필수, Minor/Status 선택, 하이픈 구분)

Xref로 기준도/공통도 분리, 경로/참조 방식 전략을 표준화

**CTB/STB(플롯 스타일)**은 프로젝트에서 한 방식으로 고정하고 혼용 금지

대시(숨은선) 스케일 문제는 MSLTSCALE/PSLTSCALE 같은 변수 관리가 핵심

**뷰포트별 레이어 동결(VP Freeze)**로 시트마다 표현을 단순화

**블록 속성(Attributes) + 데이터 추출(Data Extraction)**로 스케줄/부재리스트 자동화

철근 상세/배근 표기는 ACI 315 계열(구조도면/배근도면 개념 포함) 관행을 참조

용접 기호는 AWS A2.4 또는 ISO 2553 체계를 기준으로 표기

(축척/용지) ISO 5455(축척), A시리즈 용지 규격(예: A0 1189×841) 관행

(선굵기) NCS Plotting Guidelines는 과도하게 얇은 선 사용을 경고(특히 축소 출력 시)

AI가 도면을 “제대로 못 그리는” 가장 흔한 원인 7가지와 대응

노트는 아래 문제를 막기 위해 절차를 강제하는 형태로 구성했습니다.

스케일 혼란(모델을 스케일링 해버림)

해결: 모델은 무조건 1:1, 축척은 레이아웃/뷰포트에서만

주석 크기 불일치(1:50에서는 크고, 1:100에서는 작음)

해결: Annotative 또는 “레이아웃 주석” 중 하나로 고정

레이어가 없거나 ByObject 속성이 섞임 → 선굵기/색/출력이 무너짐

해결: ByLayer 원칙 + 템플릿에서 레이어/플롯 규칙 고정

대시(숨은선) 출력이 실선처럼 보임

해결: MSLTSCALE/PSLTSCALE 등 라인타입 스케일 표준값 고정

시트마다 보여야 할 레이어가 달라서 난잡함

해결: 뷰포트별 VP Freeze로 표현 분리

스케줄/부재리스트가 수작업(오류/누락)

해결: 블록 속성 → 데이터 추출로 표 자동 생성

철근/철골 상세는 ‘설계값’과 ‘표기’가 섞여 AI가 혼란

해결: “설계 입력(값)”과 “제도 표현(표기/마크/스케줄)”을 절차에서 분리

노트에서 강제하는 AI 제도 파이프라인(모든 도면 공통)

(문서 0~6장에 가장 자세히 정리되어 있습니다)

입력 데이터 검증: 단위, 기준점, 그리드, 레벨, 부재 리스트, 표기 규칙 누락/모순 기록

템플릿 로딩: 레이어/스타일/블록/CTB(or STB) 불러오기

기준 작성: 그리드/레벨/기준점(프로젝트 공통)

주요 형상 작성: 외곽 → 내부 → 반복 모듈

상세 요소 작성: 개구부/보강/접합부 등

주석/치수/기호 배치: 레이아웃 주석 또는 Annotative 전략 중 하나로 고정

시트 구성: 도면틀 → 뷰포트 → 축척 → 레이어 동결 → 뷰포트 잠금

QA 루프: ByLayer/대시/텍스트 높이/겹침/스케줄 누락 검사 후 수정

출력: 레이아웃 1:1 플롯

도면 종류별 “AI 실행 순서”는 이렇게 정리되어 있습니다

문서 7장에서 도면별 절차를 AI 작업 순서로 분리해 두었습니다.

건축 평면도: 그리드 → 외벽 → 내벽 → 코어/기둥 → 개구부 → 문/창 블록 → 포쉐/해치 → 실명/면적 → 치수(전체→축선→개구부→내부) → 콜아웃 → 시트

입면/단면: 기준선/레벨 → 윤곽/절단부(선굵기 계층) → 재료 해치/주기 → 치수/레벨표기 → 상세 콜아웃 → 시트

구조 일반도(GA): 구조 그리드 → 기둥/보/슬래브/개구부 → 부재명/규격 표기 → 치수 → 상세 참조 → QA

RC 배근도: (설계값 입력 전제) 뷰 선택 → 피복/기준선 → 주근/스터럽 패턴 → 간격 표기 → 바마크 → 스케줄 자동 집계

철골 일반도: 그리드 → 부재 배치/표기 → 레벨 → 접합부 콜아웃 → (선택) BOM/부재리스트

철골 접합부 상세도: 뷰포트 확대 → 부재 절단/표현 → 플레이트/볼트 패턴 → 치수 체계 → 용접기호 → 부품 콜아웃/BOM → QA

RC/부재리스트/철근리스트(표 도면): 블록 속성 설계 → 데이터 추출 → 테이블 배치/QA

원하시면, 지금 작성한 노트의 내용을 기반으로 당신이 만든 CAD 엔진의 실제 명령/함수 이름에 맞춰

set_layer() / draw_polyline() / offset() / trim() / add_dim() 같은 실행 스크립트 템플릿(도면 타입별 프롬프트/플랜)

입력 JSON 스키마(그리드/부재/개구부/상세/스케줄)
까지 “AI가 바로 실행 가능한 형태”로 정리해 줄 수 있어요.


좋아. **AI가 바로 “실행 가능한 형태”**로 도면을 만들 수 있도록, 아래 3가지를 한 번에 묶어서 준비했어.

입력 JSON 스키마(설계/요구 데이터)

실행용 JSON DSL 스키마(도면을 그리는 절차/명령 시퀀스)

도면 타입별 플랜 템플릿 + 프롬프트 템플릿 + 실행기(어댑터) 샘플

다운로드

MCP CAD Agent Kit v1 (ZIP) 다운로드

ZIP 안에 뭐가 들어있나
1) 스키마 2종

schemas/design_input_v1.schema.json
→ 그리드/레벨/벽/개구부/RC/철골/철근세트/도면요청 등 “설계 입력”을 담는 표준 구조

schemas/drafting_plan_v1.schema.json
→ AI가 만들어내는 실행 계획(JSON DSL) 구조
(레이어/블록/레이아웃/뷰포트 + sequence(명령 리스트))

2) 프롬프트 템플릿

prompt_templates_ko.md
→ Planner(System Prompt), Executor, QA 프롬프트를 그대로 복붙해서 운영 가능
핵심 규칙 포함:

모델은 항상 1:1

축척은 뷰포트에서만

ByLayer 강제

누락 값은 질문 대신 assumptions에 기록 + 필요시 Z-TBD 레이어에 placeholder

3) 도면 타입별 플랜 스켈레톤(템플릿)

templates/plan_skeleton_A_FLOOR_PLAN.json

templates/plan_skeleton_S_RC_REBAR_DETAIL.json

templates/plan_skeleton_S_STEEL_CONNECTION_DETAIL.json

templates/plan_skeleton_S_RC_MEMBER_SCHEDULE.json

템플릿은 “macro op” 중심이라 AI가 흔들리지 않고, 엔진이 반복작업을 결정론적으로 처리하게 설계했어.

4) 예시 입력/예시 플랜

examples/design_input_demo.json : 최소 설계 입력 예시

examples/drafting_plan_demo_A101_expanded.json : macro 없이 기본 op만으로 전개된 실행 예제
(당장 어댑터만 붙이면 실행되는 형태로 만든 데모)

5) 실행기/검증기 샘플 코드

executor_adapter_sample.py
→ 네 CAD 엔진 함수명에 맞춰 CadAdapter만 구현하면, drafting_plan을 순서대로 실행

validate_json.py
→ 스키마 검증 CLI

6) MCP 툴 스펙(권장)

mcp_tools_spec.json
→ MCP에서 추천하는 툴: cad.validate_plan, cad.execute_plan, cad.query

네가 구현해야 하는 최소 연결부(가장 중요한 부분)
A. MCP Tool을 “한 방 실행”으로 만들기 (권장)

AI가 선을 하나씩 그리게 하면 흔들리기 쉬워서, AI는 plan JSON만 만들고, 네 엔진이 plan을 실행하는 형태가 안정적이야.

cad.validate_plan(plan) : 스키마 검증 + 기본 규칙 위반 체크

cad.execute_plan(plan) : plan 전체 실행(결정론)

cad.query(...) : QA를 위한 상태 질의(선택)

B. CadAdapter에 네 엔진 함수 연결

executor_adapter_sample.py 안에 이미 인터페이스를 만들어뒀어.

예를 들어 네 엔진이 아래처럼 생겼다면:

set_layer(name)

draw_line(x1,y1,x2,y2)

draw_polyline(points, closed)

add_text(x,y,h,str)

add_dim_linear(...)

create_layout(...)

create_viewport(...)

그걸 CadAdapter.line(), CadAdapter.text() 등으로 그대로 매핑하면 돼.

“AI가 똑바로 도면 그리게 하는” 운영 파이프라인(실전)

design_input JSON 생성

사용자 입력/DB/BIM/CSV → design_input으로 정규화

validate_json.py로 스키마 통과 확인

Planner AI가 drafting_plan JSON 생성

prompt_templates_ko.md의 Planner 프롬프트 사용

출력은 오직 JSON (설명 금지)

plan 검증

schema 통과 + 규칙 위반(스케일링/ByLayer 위반 등) 검사

결정론 실행

cad.execute_plan(plan)로 한 번에 실행

QA 루프(선택)

qa_check 결과를 보고, QA Agent가 수정 op만 생성 → 재실행

바로 테스트하는 방법(키트 기준)

ZIP 풀고(폴더 기준 mcp_cad_agent_kit_v1/):

1) 스키마 검증
python validate_json.py --schema schemas/design_input_v1.schema.json --json examples/design_input_demo.json
python validate_json.py --schema schemas/drafting_plan_v1.schema.json --json examples/drafting_plan_demo_A101_expanded.json

2) 실행기 연결(어댑터 구현)

executor_adapter_sample.py에서 CadAdapter의 메서드들을 네 엔진 함수로 연결.

3) 데모 플랜 실행

(네 엔진 문서 생성/플롯 부분까지 연결하면 PDF까지 떨어짐)

macro를 언제/왜 쓰나 (중요)

LLM이 가장 못하는 게 “반복적 정교 작업(수백 개 offset/trim/치수)”이야.
그래서 템플릿에는 아래처럼 macro op를 권장해놨어:

macro:draw_grids

macro:draw_arch_walls

macro:insert_doors_windows

macro:build_table_from_block_attributes

macro:create_sheet_with_viewport

이 5개만 엔진에 구현해도
건축 평면/구조 GA/스케줄류는 성공률이 확 뛰어.

다음 단계(원하면 내가 바로 만들어줄 수 있는 것)

지금 키트는 “범용 어댑터 + 스키마 + 템플릿”이야.
네 CAD 엔진의 실제 함수 목록/시그니처(대략이라도)만 주면, 나는:

CadAdapter를 네 함수명으로 완전 치환한 버전

macro 5종을 네 엔진 API로 구현한 pseudo-code/실코드 설계

건축/RC/철골/접합부/스케줄 각각에 대해 macro 확장 규칙(정확한 작도 절차)

까지 더 구체적으로 맞춰서 “바로 붙여 쓰는 형태”로 만들어 줄게.

우선은 위 ZIP을 내려받아서,
examples/drafting_plan_demo_A101_expanded.json이 네 엔진에서 끝까지 실행되도록 어댑터부터 붙이면 가장 빠르게 체감될 거야.

내 함수목록과 설명을 아래에 정리해서 보내니 네가 설명한 작업을 진행해줘. stgen-dxf-viewer MCP 서버에서 제공하는 86개 전체 함수를 기능별로 상세히 분류하여 나열해 드립니다. 1. 도면 분석 및 상태 확인 (Analysis & Status) get_dxf_status: 현재 열려 있는 DXF 파일의 경로를 반환합니다. get_dxf_summary: 파일명, 개체 수, 레이어 목록, 도면 경계 등 종합 요약을 제공합니다. get_dxf_layers: 전체 레이어 목록, 가시성, 개체 수를 확인합니다. identify_drawing_type: 도면 내용(구조, 건축, 기계 등)을 자동 판별합니다. analyze_layer_structure: 레이어 명명 규칙 및 용도를 정밀 분석합니다. analyze_region: 특정 영역 내의 개체들을 분석합니다. analyze_pattern: 지정된 영역에서 그리드, 선형, 원형 배치 등의 반복 패턴을 감지합니다. count_by_type: 도면 내 개체들을 타입별로 집계합니다. count_blocks: 블록 이름별로 삽입된 개수를 집계합니다. compare_layers: 두 레이어 간의 개체 타입, 수, 위치 차이를 비교합니다. 2. 개체 생성 (Creation) create_line: 두 점을 연결하는 선(Line)을 생성합니다. create_polyline: 여러 정점을 가진 연속선(Polyline)을 생성합니다. create_circle: 중심점과 반지름으로 원을 생성합니다. create_arc: 중심점, 반지름, 시작/끝 각도로 호를 생성합니다. create_rectangle: 두 모서리 점으로 직사각형(폐쇄 폴리라인)을 생성합니다. create_text: 지정된 위치와 높이로 단일행 텍스트를 생성합니다. create_dimension: 두 점 사이의 선형 치수(수평, 수직, 정렬)를 생성합니다. create_hatch: 폐쇄된 경계 안에 해치 패턴(솔리드, 라인, 크로스)을 생성합니다. create_leader: 지시선(화살표 및 텍스트 포함)을 생성합니다. create_block: 선택한 개체들을 묶어 새로운 블록 정의를 만듭니다. create_bolt_symbol: 볼트 기호(원 안의 X 표시)를 생성합니다. create_center_mark: 원이나 호의 중심 표시(+)를 생성합니다. 3. 개체 수정 및 편집 (Modification) move_entities: 개체들을 지정된 벡터만큼 이동합니다. copy_entities: 개체들을 지정된 위치로 복사합니다. rotate_entities: 기준점을 중심으로 개체들을 회전합니다. scale_entities: 기준점을 중심으로 개체들의 크기를 배율 조정합니다. delete_entities: 선택한 개체들을 삭제합니다. erase_by_bounds: 특정 영역 내의 개체들을 한꺼번에 삭제합니다 (Window/Crossing 모드). trim_extend: 경계 개체에 맞춰 선을 자르거나 연장합니다. offset_entity: 선, 원, 폴리라인 등을 일정 간격으로 평행 복사합니다. mirror_entities: 대칭축을 기준으로 개체들을 대칭 복사/이동합니다. array_copy: 개체들을 사각 또는 원형 배열로 복사합니다. break_entity: 개체를 특정 지점에서 두 개로 나눕니다. divide_entity: 개체를 N등분하는 점들을 계산합니다. join_entities: 연결된 선, 호, 폴리라인 등을 하나의 폴리라인으로 결합합니다. explode_block: 블록 삽입체(Insert)를 개별 구성 개체로 분해합니다. stretch: 선택 영역 내의 정점들만 이동시켜 개체를 늘리거나 줄입니다. lengthen: 선이나 호의 길이를 증분, 퍼센트 또는 절대값으로 조정합니다. fillet_chamfer: 두 선이 만나는 모서리를 둥글게(Fillet) 또는 각지게(Chamfer) 처리합니다. edit_text: 기존 텍스트나 MText의 내용을 수정합니다. close_polyline: 폴리라인의 시작점과 끝점을 연결하거나 분리합니다. reverse_polyline: 폴리라인의 정점 순서를 반대로 바꿉니다. 4. 속성 변경 (Properties) change_entity_color: 개체의 색상(ACI 번호)을 변경합니다. change_entity_layer: 개체의 소속 레이어를 변경합니다. change_entity_linetype: 개체의 선 종류(Dashed, Center 등)를 변경합니다. set_current_layer: 새 개체가 생성될 활성 레이어를 설정합니다. create_layer: 새로운 레이어를 생성합니다 (색상, 선 종류 지정 가능). set_layer_visibility: 특정 레이어를 켜거나 끕니다. merge_layers: 여러 레이어의 개체들을 하나의 타겟 레이어로 합칩니다. 5. 조회 및 검색 (Query & Search) find_entities: 레이어, 타입, 범위 등 조건에 맞는 개체를 찾습니다. find_annotations: 주석, 라벨, 노트, 치수, 지시선 등을 찾습니다. find_connected_entities: 특정 점에 연결된 모든 개체들을 추적하여 찾습니다. find_intersections: 두 개체 간의 모든 교차점을 찾아냅니다. find_parallel_lines: 도면 내에서 평행한 선 쌍과 그 간격을 찾습니다. find_replace_text: 도면 전체에서 특정 문자열을 찾아 바꿉니다. detect_symbols: 볼트, 용접, 중심선 등 표준 CAD 기호들을 감지합니다. get_entity_properties: 특정 개체의 모든 상세 속성 데이터를 가져옵니다. get_entity_points: 개체의 주요 점(시작, 끝, 중심, 중간, 정점)들을 가져옵니다. get_selected_entities: 사용자가 마우스로 선택한 개체 정보를 가져옵니다. list_all_texts: 도면 내 모든 텍스트의 실제 내용과 위치를 리스트화합니다. list_blocks: 도면에 정의된 모든 블록의 정보를 나열합니다. 6. 측정 및 공간 계산 (Measurement & Spatial) measure_distance: 두 지점 사이의 거리를 측정합니다. measure_angle: 두 선 사이의 각도를 측정합니다. measure_arc_length: 호 또는 곡선 폴리라인 세그먼트의 길이를 측정합니다. calculate_area: 폐쇄된 폴리라인이나 원의 면적을 계산합니다. calculate_perimeter: 개체의 둘레 또는 원주를 계산합니다. sum_lengths: 선택한 여러 선형 개체들의 총 길이를 합산합니다. sum_areas: 선택한 여러 폐쇄 개체들의 총 면적을 합산합니다. get_region_bounds: 특정 영역 내 개체들의 실제 경계(Bounding Box)를 계산합니다. verify_alignment: 개체들이 수평/수직 등으로 정렬되어 있는지 검증합니다. align_to_baseline: 여러 개체를 특정 기준선에 맞춰 정렬합니다. snap_to_grid: 점들을 지정된 그리드 간격에 맞춰 정렬(스냅)합니다. generate_bom: 도면의 내용을 바탕으로 자재 리스트(BOM) 문서를 생성합니다. 7. 영역 작업 및 추출 (Region & Extraction) extract_region: 특정 영역의 데이터를 JSON 또는 CAD 명령어로 추출합니다 (복사용). extract_dimensions: 치수 개체들로부터 실제 측정값과 텍스트를 추출합니다. extract_dxf_entities: 현재 도면의 개체 데이터를 형식화된 데이터로 추출합니다. clone_region: 소스 영역의 모든 개체를 타겟 위치로 복제합니다. rotate_region: 특정 영역 내의 모든 개체를 일괄 회전합니다. scale_region: 특정 영역 내의 모든 개체를 일괄 배율 조정합니다. 8. 파일 및 뷰 제어 (File & View) capture_dxf_view: 현재 보고 있는 화면을 PNG 이미지(Base64)로 캡처합니다. zoom_extents: 도면의 모든 내용이 보이도록 화면을 맞춥니다. zoom_to_bounds: 지정된 사각 영역으로 화면을 확대합니다. save_dxf: 현재 변경 사항을 DXF 파일로 저장합니다. export_entities: 선택한 개체들만 추출하여 별도의 DXF 보관 파일로 만듭니다. insert_block: 정의된 블록을 특정 위치, 회전, 배율로 삽입합니다. undo_last_action: 마지막 작업을 취소합니다.

좋아요. 보내주신 stgen-dxf-viewer MCP 86개 함수 목록(도면 분석/생성/수정/속성/검색/측정/영역/파일·뷰) 기준으로, 제가 앞서 설명했던 “Plan(JSON) → 결정론 실행(Executor) → QA 루프” 방식으로 바로 쓸 수 있는 에이전트 키트 v2를 만들어 두었습니다.

아래 파일을 받으면, 당신의 MCP 서버 함수명(86개) 을 그대로 쓰는 스키마/템플릿/실행기(샘플)까지 포함되어 있습니다.

stgen_dxf_agent_kit_v2.zip 다운로드

추가로, 이전에 요청하셨던 “제도 안내 노트(절차 중심)” 문서도 함께 다시 드립니다(이미 만들어둔 파일):

AI_CAD_Drafting_Note_KO_v3.docx 다운로드

AI_CAD_Drafting_Note_KO_v3.pdf 다운로드

이번 v2 키트에서 “당신 함수목록”으로 반영된 것
1) stgen 86개 툴 이름을 그대로 쓰는 Plan 스키마

schemas/drafting_plan_stgen_v1.schema.json 에서 step.tool enum이 당신이 적어주신 86개 함수명과 1:1로 들어가 있습니다.

예) create_line, offset_entity, find_entities, extract_dimensions, save_dxf, capture_dxf_view, … 전부 포함.

2) AI가 “그리는 순서”만 출력하게 하는 Planner 프롬프트

prompt_templates_ko.md에

Planner: design_input → drafting_plan(JSON only)

QA Agent: 실행 후 도면 검사 → plan patch(JSON only)
형태로 템플릿이 들어있습니다.

3) 결정론 실행기(Executor) 샘플

src/stgen_plan_executor.py

plan을 읽고

macro를 전개하고

$var 변수 치환하고

각 step을 순서대로 MCP tool call 합니다.

⚠️ 단, 실제 MCP 호출부는 환경마다 달라서 McpClient.call(tool,args)만 “당신 orchestrator”에 연결하면 됩니다.
(키트는 기본 --dry-run으로 호출 로그만 찍도록 되어 있음)

4) 매크로(반복 제도 절차)를 tool-call로 자동 전개

src/macro_library.py

macro:setup_layers

macro:draw_grids

macro:draw_walls

macro:draw_openings

macro:add_room_labels

macro:add_dimensions_basic

macro:steel_connection_detail

macro:rc_rebar_detail

macro:member_schedule_table

macro:qa_snapshot

macro:fit_and_save

처럼 AI가 흔들리기 쉬운 반복 절차를 매크로로 고정하고, 실행 전에 create_ / offset_entity / create_text / create_dimension / save_dxf…* 같은 primitive tool step으로 펼칩니다.

5) “AI가 실제로 도면을 그리는 순서”를 stgen 툴 기준으로 정리한 플레이북 추가

키트에 AI_Drafting_Playbook_Stgen_KO.md를 넣어두었습니다.
(그리드→벽→개구부→텍스트→치수→QA→저장 순서 + 어떤 stgen 함수 쓰는지)

키트 내부 구성(요약)

README_KO.md : 운영 파이프라인(Plan→Execute→QA) 설명

AI_Drafting_Playbook_Stgen_KO.md : 절차 중심 제도 규약(도구명 포함)

schemas/design_input_v2.schema.json : 설계 입력 스키마(그리드/벽/구조/철골/철근/표 등)

schemas/drafting_plan_stgen_v1.schema.json : stgen 86 tool + macro plan 스키마

src/stgen_plan_executor.py : 실행기 샘플

src/macro_library.py : macro 전개

src/plan_validator.py : 규칙/스키마 검증

templates/ : 도면 타입별 plan skeleton

examples/ : design_input 데모 + macro plan + expanded plan(전개 결과)

바로 테스트할 수 있는 예시

키트 안에 있는 예시를 보면 이해가 빠릅니다.

examples/drafting_plan_demo_A101_macro.json : 매크로 기반

examples/drafting_plan_demo_A101_expanded.json : 매크로 전개 후 순수 tool-call 단계만 남은 버전

중요한 현실 포인트(정직하게)

제가 지금 웹/공개문서에서 **stgen 각 tool의 “정확한 args 스키마(파라미터 키 이름)”**까지는 확인할 수 없었습니다(확인 가능한 공개 스키마가 검색되지 않아, 일반적인 CAD 인자 포맷으로 작성했습니다).

그래서 키트의 args는 다음처럼 권장 포맷을 씁니다:

create_line: { "start":[x,y], "end":[x,y] }

create_polyline: { "points":[[x,y]...], "closed":false }

create_text: { "insert":[x,y], "height":h, "text":"...", "align":"CENTER" }

save_dxf: { "path":"..." }

만약 당신 stgen MCP가 다른 키를 요구한다면, 해결은 아주 간단합니다:

stgen_plan_executor.py의 client.call(tool,args) 직전에
**args를 변환하는 “어댑터 레이어”**를 한 번 넣어주면 됩니다.
(예: insert → position, points → vertices 같은 매핑)

다음 단계(당신이 바로 할 것)

zip을 풀기

src/stgen_plan_executor.py --dry-run으로 plan이 잘 도는지 확인

당신 MCP 호출 코드에서 McpClient.call()만 연결

실제 실행 후 capture_dxf_view, get_dxf_summary, extract_dimensions 등으로 QA 루프 구성

원하시면, 다음 작업도 “질문 없이” 제가 바로 만들어드릴 수 있어요(당신 쪽 파일/스키마가 없어도 진행 가능):

당신 MCP 서버가 실제로 요구하는 args 키에 맞춘 “자동 변환 어댑터” (args_map.json + 변환 코드)

도면 타입별(건축/RC/철골/접합부/부재리스트/상세도) 매크로를 더 촘촘하게(예: 벽 해치, 문 스윙, 철근 정착/후크, 용접기호 표준화 등)

QA Agent가 extract_dimensions / list_all_texts / detect_symbols를 기반으로 “누락/중복/충돌”을 자동 리포팅하는 규칙 세트

일단은 위 zip을 받아서 구조를 보시면, 지금 겪고 계신 “AI가 직접 제도 못함” 문제가 Plan 기반 결정론 실행으로 확 줄어들 겁니다.

진행 완료했어. **네 stgen-dxf-viewer MCP(86개 함수)**를 기준으로, 내가 앞서 말한 “다음 작업” 3가지를 한 번에 반영한 Agent Kit v3를 만들어 놨어.


stgen_dxf_agent_kit_v3.zip 다운로드



v3에서 “다음 작업”으로 추가/완성한 것
1) canonical args → 실제 MCP args 자동 변환(어댑터)
네가 말했듯이 서버마다 tool args 키가 조금씩 달라서 AI가 잘못 호출하면 바로 깨져.
그래서 Plan은 canonical args로 고정하고, 실행 직전에 변환하는 구조로 만들었어.


src/args_adapter.py : 변환기


args_map/args_map_identity.json : 변환 없음(기본)


args_map/args_map_example_rename.json : 예시(rename)



즉, AI는 항상 같은 “표준 키”로 plan을 만들고, 네 서버가 요구하는 키는 args_map으로 해결.


2) “실제 args 키”를 빠르게 알아내는 Probe 유틸리티
네 MCP 서버가 요구하는 정확한 파라미터 키를 내가 지금 확정할 수는 없으니(공개 시그니처가 없어서),
대신 네가 한 번 실행하면 에러 메시지로 필수 키를 빠르게 확정할 수 있게 “Probe”를 넣었어.


src/args_probe.py


examples/args_probe_cases.json


이걸로 create_line / create_text / create_dimension / create_layer ... 같은 대표 tool을 시험 호출해서
에러 메시지 기반으로 args_map을 완성하면 돼.

3) QA 엔진 + 규칙 세트(결정론 검사)
실행 후 “잘 그려졌는지”를 AI 감으로 판단하면 또 흔들려서,
stgen 분석/추출 기능을 묶어 **qa_report(JSON)**를 뽑는 엔진을 만들었어.


src/qa_engine.py : QA 리포트 생성


src/qa_rules.py : 규칙들(필수 레이어, placeholder 텍스트, 치수 최소 개수 등)


examples/qa_report_demo.json


examples/patch_plan_demo.json : qa_report를 보고 “수정 plan” 만드는 예시



추가로 같이 개선한 것(중요)
✅ Executor에 $LAST(마지막 생성 엔티티) 지원 추가
매크로에서 offset_entity 같은 걸 하려면 “방금 만든 엔티티 ID”를 참조해야 하는 경우가 많아.
그래서 src/stgen_plan_executor.py가 매 step 실행 후:


vars.LAST_RESULT


vars.LAST_IDS


vars.LAST (가능하면 마지막 entity id)


를 자동 갱신하도록 넣어뒀어.
그래서 매크로에서 "$LAST"를 쓰면 “직전 create 결과”를 참조하는 흐름이 가능해졌어.

키트 구조(요약)


schemas/


design_input_v3.schema.json


drafting_plan_stgen_v2.schema.json




src/


stgen_plan_executor.py (macro 전개 + 변수치환 + args 변환 + tool 실행)


args_adapter.py


macro_library.py


qa_engine.py, qa_rules.py


validate_json.py (스키마 검증 CLI)


args_probe.py




templates/ : 도면 타입별 skeleton


examples/ : demo design_input, demo plan(macro/expanded), qa/patch, probe cases


docs/


tool_canonical_args.md (86개 전부 canonical args 예시 포함)


integration_checklist_ko.md





너가 지금 바로 할 “다음 3단계” (가장 빠른 적용 루트)
1) 스키마 검증
python src/validate_json.py --schema schemas/design_input_v3.schema.json --json examples/design_input_demo.json
python src/validate_json.py --schema schemas/drafting_plan_stgen_v2.schema.json --json examples/drafting_plan_demo_A101_macro.json

2) dry-run으로 실행 시퀀스 확인
python src/stgen_plan_executor.py --plan examples/drafting_plan_demo_A101_macro.json --args-map args_map/args_map_identity.json --dry-run

3) 실제 MCP 호출 연결(핵심)
src/stgen_plan_executor.py의 McpClient.call(tool,args)만
네 orchestrator 코드에 맞게 바꾸면 바로 실작도가 돼.
그 다음 실행 후:


src/qa_engine.py로 QA 리포트 생성


qa_report 기반 patch_plan 생성 → 재실행



벽(WALL) 매크로에 대한 현실적인 안내(중요)
벽은 “센터라인+두께 → 오프셋” 방식이 이상적이지만, 오프셋은 대개 엔티티 ID가 필요해.
그래서 v3에서는 안정성을 위해:


boundary(외곽 경계 폴리라인) 기반 입력이 있으면 그걸 우선 사용하도록 설계했어.


centerline+thickness만 있는 경우는 $LAST 기반 오프셋 워크플로우로 가는 “fallback”만 넣어놨고,
프로젝트마다 offset_entity가 뭘 요구하는지에 따라 약간의 보완이 필요해.


즉, 처음 성공률을 최대로 하려면
design_input에서 벽을 가능하면 boundary로 주는 게 가장 빨라.

원하면, 다음도 “추가 작업”으로 바로 더 진행할 수 있어(질문 없이 진행 가능):


네 실제 MCP args 포맷(에러 메시지/로그) 기준으로 args_map을 완성한 맞춤형 v4


건축평면(A) / 구조(GA) / 철골접합 / RC배근 / 스케줄 각각 macro를 더 촘촘하게(문 스윙, 창틀 2중선, 해치, 볼트 배열, 텍스트 겹침 방지 규칙 등)


QA 규칙 확장: 레이어 위반, 텍스트 겹침(근사), 치수 중복/누락, 그리드 간격 이상, 심벌 누락 등


지금은 v3 zip을 받아서 (1) dry-run → (2) McpClient.call 연결 → (3) probe로 args_map 확정 이 3개만 하면 곧바로 “AI가 plan을 만들고 엔진이 안정적으로 작도”하는 루프가 돌아갈 거야.
